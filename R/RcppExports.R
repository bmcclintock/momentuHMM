# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Get XB
#'
#' Loop for computation of design matrix (X) times the working scale parameters (B). Written in C++. Used in \code{\link{w2n}}.
#'
#' @param DM design matrix
#' @param Xvec working parameters
#' @param nbObs number of observations
#' @param nr number of rows in design matrix
#' @param nc number of column in design matrix
#' @param circularAngleMean indicator for whether or not circular-circular regression model
#' @param consensus indicator for whether or not circular-circular regression consensus model
#' @param rindex row index for design matrix
#' @param cindex column index for design matrix
#' @param nbStates number of states
#' @param refCoeff intercept coefficient for circular-circular regression model
#'
#' @return XB matrix
XBloop_rcpp <- function(DM, Xvec, nbObs, nr, nc, circularAngleMean, consensus, rindex, cindex, nbStates, refCoeff = 1.0) {
    .Call(`_momentuHMM_XBloop_rcpp`, DM, Xvec, nbObs, nr, nc, circularAngleMean, consensus, rindex, cindex, nbStates, refCoeff)
}

combine <- function(list, NAvalue) {
    .Call(`_momentuHMM_combine`, list, NAvalue)
}

cbindmean2 <- function(x, y) {
    .Call(`_momentuHMM_cbindmean2`, x, y)
}

cbindmean3 <- function(x, y, z) {
    .Call(`_momentuHMM_cbindmean3`, x, y, z)
}

cbindsigma2 <- function(x, y, xy) {
    .Call(`_momentuHMM_cbindsigma2`, x, y, xy)
}

cbindsigma3 <- function(x, y, z, xy, xz, yz) {
    .Call(`_momentuHMM_cbindsigma3`, x, y, z, xy, xz, yz)
}

#' Gamma density function
#'
#' Probability density function of the gamma distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param mu Mean
#' @param sigma Standard deviation
#'
#' @return Vector of densities
dgamma_rcpp <- function(x, mu, sigma) {
    .Call(`_momentuHMM_dgamma_rcpp`, x, mu, sigma)
}

#' Weibull density function
#'
#' Probability density function of the Weibull distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param shape Shape
#' @param scale Scale
#'
#' @return Vector of densities
dweibull_rcpp <- function(x, shape, scale) {
    .Call(`_momentuHMM_dweibull_rcpp`, x, shape, scale)
}

#' Normal density function
#'
#' Probability density function of the normal distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param mean Mean of the distribution 
#' @param sd Standard deviation of the distribution 
#'
#' @return Vector of densities
dnorm_rcpp <- function(x, mean, sd) {
    .Call(`_momentuHMM_dnorm_rcpp`, x, mean, sd)
}

#' Log-normal density function
#'
#' Probability density function of the log-normal distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param meanlog Mean of the distribution on the log-scale
#' @param sdlog Standard deviation of the distribution on the log-scale
#'
#' @return Vector of densities
dlnorm_rcpp <- function(x, meanlog, sdlog) {
    .Call(`_momentuHMM_dlnorm_rcpp`, x, meanlog, sdlog)
}

#' Exponential density function
#'
#' Probability density function of the exponential distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param rate Rate
#' @param foo Unused (for compatibility with template)
#'
#' @return Vector of densities
dexp_rcpp <- function(x, rate, foo) {
    .Call(`_momentuHMM_dexp_rcpp`, x, rate, foo)
}

#' Von Mises density function
#'
#' Probability density function of the Von Mises distribution, defined as a function
#' of the modified Bessel function of order 0 (written in C++)
#'
#' @param x Vector of quantiles
#' @param mu Mean
#' @param kappa Concentration
#'
#' @return Vector of densities
dvm_rcpp <- function(x, mu, kappa) {
    .Call(`_momentuHMM_dvm_rcpp`, x, mu, kappa)
}

#' Wrapped Cauchy density function
#'
#' Probability density function of the wrapped Cauchy distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param mu Mean
#' @param rho Concentration
#'
#' @return Vector of densities
dwrpcauchy_rcpp <- function(x, mu, rho) {
    .Call(`_momentuHMM_dwrpcauchy_rcpp`, x, mu, rho)
}

#' Probability density function of the beta distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param shape1 Shape1
#' @param shape2 Shape2
#'
#' @return Vector of densities
dbeta_rcpp <- function(x, shape1, shape2) {
    .Call(`_momentuHMM_dbeta_rcpp`, x, shape1, shape2)
}

#' Poisson density function
#'
#' Probability density function of the Poisson distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param rate Rate
#' @param foo Unused (for compatibility with template)
#'
#' @return Vector of densities
dpois_rcpp <- function(x, rate, foo) {
    .Call(`_momentuHMM_dpois_rcpp`, x, rate, foo)
}

#' Bernoulli density function
#'
#' Probability density function of the Bernoulli distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param prob success probability
#' @param foo Unused (for compatibility with template)
#'
#' @return Vector of densities
dbern_rcpp <- function(x, prob, foo) {
    .Call(`_momentuHMM_dbern_rcpp`, x, prob, foo)
}

#' C++ implementation of multivariate Normal probability density function for multiple inputs
#'
#'@param x data matrix of dimension \code{p x n}, \code{p} being the dimension of the
#'data and n the number of data points.
#'@param mean mean vectors matrix of dimension \code{p x n}
#'@param varcovM (nbStates * (p + (p * p - p)/2 )) x n matrix of all sds (sd.x.state1, sd.x.state2, ..., sd.y.state1, ...) and then correlations (corr.xy.state1, corr.xy.state2, ..., corr.xz.state1, corr.xz.state2, ...) from lower triangle of variance-covariance matrix.
#'
#'@return matrix of densities of dimension \code{K x n}.
dmvnorm_rcpp <- function(x, mean, varcovM) {
    .Call(`_momentuHMM_dmvnorm_rcpp`, x, mean, varcovM)
}

#' Categorical density function
#'
#' Probability density function of the categorical distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param prob success probability
#' @param foo Unused (for compatibility with template)
#'
#' @return Vector of densities
dcat_rcpp <- function(x, prob, foo) {
    .Call(`_momentuHMM_dcat_rcpp`, x, prob, foo)
}

#' negative binomial density function
#'
#' Probability density function of the negative binomial distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param mu Mean of the distribution 
#' @param size Dispersion parameter
#'
#' @return Vector of densities
dnbinom_rcpp <- function(x, mu, size) {
    .Call(`_momentuHMM_dnbinom_rcpp`, x, mu, size)
}

#' logistic density function
#'
#' Probability density function of the logistic distribution (written in C++)
#'
#' @param x Vector of quantiles
#' @param location mean of the distribution 
#' @param scale Dispersion parameter
#'
#' @return Vector of densities
dlogis_rcpp <- function(x, location, scale) {
    .Call(`_momentuHMM_dlogis_rcpp`, x, location, scale)
}

#' student t density function
#'
#' Probability density function of non-central student t (written in C++)
#'
#' @param x Vector of quantiles
#' @param df degrees of freedom 
#' @param ncp non-centrality parameter
#'
#' @return Vector of densities
dt_rcpp <- function(x, df, ncp) {
    .Call(`_momentuHMM_dt_rcpp`, x, df, ncp)
}

#' Correlated random walk Rice distribution
#'
#' Probability density function of Rice distribution under the CTCRW model of Johnson et al. (2008) (written in C++)
#'
#' @param x numeric data vector of length \code{n + n} where the first \code{n} entries correspond to the step lengths and the next \code{n} entries to the corresponding previous step lengths (the first of which is NA and ignored).
#' @param beta correlation parameter 
#' @param sigma speed parameter
#'
#' @return Vector of densities
dcrwrice_rcpp <- function(x, beta, sigma) {
    .Call(`_momentuHMM_dcrwrice_rcpp`, x, beta, sigma)
}

#' Correlated random walk von Mises density function
#'
#' Probability density function of the Von Mises distribution under the CTCRW model of Johnson et al. (2008) (written in C++)
#'
#' @param x numeric data vector of length \code{n + n + n} where the first \code{n} entries correspond to angles (von Mises distribution), the next \code{n} entries to the corresponding step lengths, and the last \code{n} entries to the corresponding previous step lengths.
#' @param beta correlation parameter 
#' @param sigma speed parameter
#'
#' @return Vector of densities
dcrwvm_rcpp <- function(x, beta, sigma) {
    .Call(`_momentuHMM_dcrwvm_rcpp`, x, beta, sigma)
}

#' Matrix Exponential
#'
#' This function computes the exponential of a square matrix \code{A}, defined as the sum from \code{r=0} to infinity of \code{A^r/r!}, using the default method of \code{\link[expm]{expm}}.
#'
#' @param x a square matrix.
#' @param kappa maximum allowed value for the row sums of the off-diagonal elements in the state transition rate matrix, such that the minimum value for the diagonal elements is \code{-kappa}. Default: \code{Inf}. Setting less than \code{Inf} can help avoid numerical issues during optimization.
#' @param check logical indicating whether or not to check transition probability matrix for issues
#'
#' @return The matrix exponential of x.
expmatrix_rcpp <- function(x, kappa = NA_real_, check = FALSE) {
    .Call(`_momentuHMM_expmatrix_rcpp`, x, kappa, check)
}

#' Get design matrix
#'
#' Loop for creating full design matrix (X) from pseudo-design matrix (DM). Written in C++. Used in \code{getDM}.
#'
#' @param X full design matrix
#' @param covs matrix of covariates
#' @param DM pseudo design matrix
#' @param nr number of rows in design matrix
#' @param nc number of column in design matrix
#' @param cov covariate names
#' @param nbObs number of observations
#'
#' @return full design matrix (X)
getDM_rcpp <- function(X, covs, DM, nr, nc, cov, nbObs) {
    .Call(`_momentuHMM_getDM_rcpp`, X, covs, DM, nr, nc, cov, nbObs)
}

#' Negative log-likelihood
#'
#' Computation of the negative log-likelihood (forward algorithm - written in C++)
#'
#' @param nbStates Number of states,
#' @param covs Covariates,
#' @param data A \code{\link{momentuHMMData}} object of the observations,
#' @param dataNames Character vector containing the names of the data streams,
#' @param dist Named list indicating the probability distributions of the data streams. 
#' @param Par Named list containing the state-dependent parameters of the data streams, matrix of regression coefficients 
#' for the transition probabilities ('beta'), and initial distribution ('delta').
#' @param aInd Vector of indices of the rows at which the data switches to another animal
#' @param zeroInflation Named list of logicals indicating whether the probability distributions of the data streams are zero-inflated.
#' @param oneInflation Named list of logicals indicating whether the probability distributions of the data streams are one-inflated.
#' @param stationary \code{false} if there are time-varying covariates in \code{formula} or any covariates in \code{formulaDelta}. If \code{true}, the initial distribution is considered
#' equal to the stationary distribution. Default: \code{false}.
#' @param knownStates Vector of values of the state process which are known prior to fitting the
#' model (if any). Default: NULL (states are not known). This should be a vector with length the number
#' of rows of 'data'; each element should either be an integer (the value of the known states) or NA if
#' the state is not known.
#' @param betaRef Indices of reference elements for t.p.m. multinomial logit link.
#' @param mixtures Number of mixtures for the state transition probabilities
#' @param dtIndex time difference index for calculating transition probabilities of hierarchical continuous-time models
#' @param CT logical indicating whether to fit discrete-time approximation of a continuous-time model
#' @param kappa maximum allowed value for the row sums of the off-diagonal elements in the state transition rate matrix, such that the minimum value for the diagonal elements is \code{-kappa}. Default: \code{Inf}. Setting less than \code{Inf} can help avoid numerical issues during optimization, in which case the transition rate parameters \code{beta} are on the logit scale (instead of the log scale).
#' 
#' @return Negative log-likelihood
nLogLike_rcpp <- function(nbStates, covs, data, dataNames, dist, Par, aInd, zeroInflation, oneInflation, stationary, knownStates, betaRef, mixtures, dtIndex, CT = FALSE, kappa = NA_real_) {
    .Call(`_momentuHMM_nLogLike_rcpp`, nbStates, covs, data, dataNames, dist, Par, aInd, zeroInflation, oneInflation, stationary, knownStates, betaRef, mixtures, dtIndex, CT, kappa)
}

#' Stationary distribution for a continuous-time Markov chain
#'
#' Written in C++. 
#'
#' @param A transition rate matrix (of dimension nbStates x nbStates)
#'
#' @return row vector of stationary distribution probabilities
stationary_rcpp <- function(A) {
    .Call(`_momentuHMM_stationary_rcpp`, A)
}

#' Transition probability matrix
#'
#' Computation of the transition probability matrix, as a function of the covariates and the regression
#' parameters. Written in C++. Used in \code{\link{viterbi}}.
#'
#' @param nbStates Number of states
#' @param beta Matrix of regression parameters
#' @param covs Matrix of covariate values
#' @param betaRef Indices of reference elements for t.p.m. multinomial logit link.
#' @param CT logical indicating discrete-time approximation of a continuous-time model
#' @param dt numeric vector of length \code{nrow(covs)} indicating the time difference between observations. Ignored unless \code{CT=TRUE}.
#' @param aInd Vector of indices of the rows at which the data (i.e. \code{covs}) switches to another animal. Ignored unless \code{CT=TRUE}.
#' @param rateMatrix logical indicating whether or not to return the transition rate matrix. Ignored unless \code{CT=TRUE}.
#' @param kappa maximum allowed value for the row sums of the off-diagonal elements in the state transition rate matrix, such that the minimum value for the diagonal elements is \code{-kappa}. Default: \code{Inf}. Setting less than \code{Inf} can help avoid numerical issues during optimization, in which case the transition rate parameters \code{beta} are on the logit scale (instead of the log scale).
#' @param check logical indicating whether or not to check transition probability matrix for issues. Ignored unless \code{CT=TRUE}.
#'
#' @return Three dimensional array \code{trMat}, such that \code{trMat[,,t]} is the transition matrix at
#' time t.
trMatrix_rcpp <- function(nbStates, beta, covs, betaRef, CT = FALSE, dt = as.numeric( c()), aInd = as.integer( c()), rateMatrix = FALSE, kappa = NA_real_, check = TRUE) {
    .Call(`_momentuHMM_trMatrix_rcpp`, nbStates, beta, covs, betaRef, CT, dt, aInd, rateMatrix, kappa, check)
}

